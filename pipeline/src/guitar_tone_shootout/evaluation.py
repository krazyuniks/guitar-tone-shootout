"""AI evaluation generation for guitar tone analysis.

This module provides two evaluation methods:

1. Algorithmic Summary (REQUIRED): Template-based descriptions derived from
   audio metrics that describe tonal characteristics in human-readable terms.

2. LLM Enhancement (OPTIONAL): Natural language descriptions generated by
   Claude API for more nuanced and context-aware evaluations.

Example:
    >>> from guitar_tone_shootout.metrics import extract_metrics, AudioMetrics
    >>> from guitar_tone_shootout.evaluation import generate_evaluation
    >>> segment_metrics = extract_metrics(audio, sample_rate)
    >>> avg_metrics = compute_shootout_averages([segment_metrics, ...])
    >>> evaluation = generate_evaluation(
    ...     segment_metrics, avg_metrics, amp_name="JCM800"
    ... )
    >>> print(evaluation.tone_description)
"""

from __future__ import annotations

import hashlib
import json
import logging
import os
from dataclasses import dataclass
from typing import TYPE_CHECKING

from pydantic import BaseModel, Field

if TYPE_CHECKING:
    from collections.abc import Sequence

from guitar_tone_shootout.metrics import AudioMetrics

logger = logging.getLogger(__name__)

# Environment variable to enable LLM evaluation
ENABLE_LLM_EVALUATION_ENV = "ENABLE_LLM_EVALUATION"
ANTHROPIC_API_KEY_ENV = "ANTHROPIC_API_KEY"

# Thresholds for algorithmic descriptions
# These are calibrated based on typical guitar amp characteristics
BRIGHTNESS_THRESHOLD_HZ = 100.0  # Centroid difference to note brightness change
BASS_ENERGY_THRESHOLD = 0.05  # Ratio difference to note bass change
MID_ENERGY_THRESHOLD = 0.05  # Ratio difference to note mid change
TREBLE_ENERGY_THRESHOLD = 0.03  # Ratio difference to note treble change
CREST_FACTOR_THRESHOLD_DB = 1.0  # dB difference to note transient difference
DYNAMIC_RANGE_THRESHOLD_DB = 2.0  # dB difference to note compression
ATTACK_TIME_THRESHOLD_MS = 5.0  # ms difference to note attack change
DECAY_RATE_THRESHOLD_DB_S = 5.0  # dB/s difference to note sustain change
TRANSIENT_DENSITY_THRESHOLD = 0.5  # transients/s difference to note


@dataclass
class MetricsDelta:
    """Computed differences between segment and shootout average metrics.

    Positive values indicate the segment metric is higher than the average.

    Attributes:
        spectral_centroid_hz: Difference in spectral centroid (brightness)
        bass_energy_ratio: Difference in bass energy ratio
        mid_energy_ratio: Difference in mid energy ratio
        treble_energy_ratio: Difference in treble energy ratio
        crest_factor_db: Difference in crest factor (transient punch)
        dynamic_range_db: Difference in dynamic range
        attack_time_ms: Difference in attack time
        sustain_decay_rate_db_s: Difference in sustain decay rate
        transient_density: Difference in transient density
        rms_dbfs: Difference in RMS level
        lufs_integrated: Difference in LUFS
    """

    spectral_centroid_hz: float
    bass_energy_ratio: float
    mid_energy_ratio: float
    treble_energy_ratio: float
    crest_factor_db: float
    dynamic_range_db: float
    attack_time_ms: float
    sustain_decay_rate_db_s: float
    transient_density: float
    rms_dbfs: float
    lufs_integrated: float


class AIEvaluation(BaseModel):
    """AI-generated evaluation of a tone.

    This model matches the AIEvaluationSchema from the backend schemas
    for seamless API integration.

    Attributes:
        model_name: The evaluation model (algorithmic or LLM model name)
        model_version: Version identifier
        tone_description: Natural language description of the tone character
        strengths: List of tone strengths/positive characteristics
        weaknesses: List of tone weaknesses/negative characteristics
        recommended_genres: Suggested musical genres for this tone
        comparison_notes: Notes from comparison with other tones
        overall_rating: Subjective quality rating (1-10 scale)
        raw_response: Complete raw response (for LLM evaluations)
    """

    model_name: str = Field(
        ..., description="Evaluation model used (algorithmic or LLM name)"
    )
    model_version: str | None = Field(
        default=None, description="Version identifier for the model"
    )
    tone_description: str = Field(
        ..., description="Natural language description of the tone character"
    )
    strengths: list[str] = Field(
        default_factory=list,
        description="List of tone strengths/positive characteristics",
    )
    weaknesses: list[str] = Field(
        default_factory=list,
        description="List of tone weaknesses/negative characteristics",
    )
    recommended_genres: list[str] = Field(
        default_factory=list,
        description="Suggested musical genres for this tone",
    )
    comparison_notes: str | None = Field(
        default=None,
        description="Notes from comparison with other tones in the shootout",
    )
    overall_rating: float | None = Field(
        default=None, ge=1.0, le=10.0, description="Subjective quality rating (1-10)"
    )
    raw_response: dict[str, object] | None = Field(
        default=None, description="Complete raw response from the AI model"
    )


class MetricsStatistics(BaseModel):
    """Statistical summary of metrics across multiple segments.

    Used for computing shootout averages and standard deviations.

    Attributes:
        mean: Mean values for each metric
        std: Standard deviation for each metric
        count: Number of samples used
    """

    mean: AudioMetrics
    std: AudioMetrics
    count: int


# =============================================================================
# Metrics Comparison Functions
# =============================================================================


def compute_metrics_delta(
    segment_metrics: AudioMetrics,
    average_metrics: AudioMetrics,
) -> MetricsDelta:
    """Compute the difference between segment metrics and shootout average.

    Args:
        segment_metrics: Metrics for the segment being evaluated
        average_metrics: Average metrics across the shootout

    Returns:
        MetricsDelta with all differences computed
    """
    return MetricsDelta(
        spectral_centroid_hz=(
            segment_metrics.spectral.spectral_centroid_hz
            - average_metrics.spectral.spectral_centroid_hz
        ),
        bass_energy_ratio=(
            segment_metrics.spectral.bass_energy_ratio
            - average_metrics.spectral.bass_energy_ratio
        ),
        mid_energy_ratio=(
            segment_metrics.spectral.mid_energy_ratio
            - average_metrics.spectral.mid_energy_ratio
        ),
        treble_energy_ratio=(
            segment_metrics.spectral.treble_energy_ratio
            - average_metrics.spectral.treble_energy_ratio
        ),
        crest_factor_db=(
            segment_metrics.core.crest_factor_db - average_metrics.core.crest_factor_db
        ),
        dynamic_range_db=(
            segment_metrics.core.dynamic_range_db - average_metrics.core.dynamic_range_db
        ),
        attack_time_ms=(
            segment_metrics.advanced.attack_time_ms - average_metrics.advanced.attack_time_ms
        ),
        sustain_decay_rate_db_s=(
            segment_metrics.advanced.sustain_decay_rate_db_s
            - average_metrics.advanced.sustain_decay_rate_db_s
        ),
        transient_density=(
            segment_metrics.advanced.transient_density
            - average_metrics.advanced.transient_density
        ),
        rms_dbfs=segment_metrics.core.rms_dbfs - average_metrics.core.rms_dbfs,
        lufs_integrated=(
            segment_metrics.advanced.lufs_integrated - average_metrics.advanced.lufs_integrated
        ),
    )


def compute_shootout_averages(
    all_metrics: Sequence[AudioMetrics],
) -> AudioMetrics:
    """Compute average metrics across all segments in a shootout.

    Args:
        all_metrics: List of AudioMetrics from all segments

    Returns:
        AudioMetrics with averaged values

    Raises:
        ValueError: If no metrics provided
    """
    if not all_metrics:
        msg = "At least one set of metrics is required to compute averages"
        raise ValueError(msg)

    count = len(all_metrics)

    # Compute averages for each metric
    avg_rms = sum(m.core.rms_dbfs for m in all_metrics) / count
    avg_peak = sum(m.core.peak_dbfs for m in all_metrics) / count
    avg_crest = sum(m.core.crest_factor_db for m in all_metrics) / count
    avg_dynamic = sum(m.core.dynamic_range_db for m in all_metrics) / count

    avg_centroid = sum(m.spectral.spectral_centroid_hz for m in all_metrics) / count
    avg_bass = sum(m.spectral.bass_energy_ratio for m in all_metrics) / count
    avg_mid = sum(m.spectral.mid_energy_ratio for m in all_metrics) / count
    avg_treble = sum(m.spectral.treble_energy_ratio for m in all_metrics) / count

    avg_lufs = sum(m.advanced.lufs_integrated for m in all_metrics) / count
    avg_transient = sum(m.advanced.transient_density for m in all_metrics) / count
    avg_attack = sum(m.advanced.attack_time_ms for m in all_metrics) / count
    avg_decay = sum(m.advanced.sustain_decay_rate_db_s for m in all_metrics) / count

    # Use first metrics for duration/sample rate (should be same for all)
    avg_duration = sum(m.duration_seconds for m in all_metrics) / count
    sample_rate = all_metrics[0].sample_rate

    # Import here to avoid circular import
    from guitar_tone_shootout.metrics import (
        AdvancedMetrics,
        CoreMetrics,
        SpectralMetrics,
    )

    return AudioMetrics(
        duration_seconds=avg_duration,
        sample_rate=sample_rate,
        core=CoreMetrics(
            rms_dbfs=avg_rms,
            peak_dbfs=avg_peak,
            crest_factor_db=avg_crest,
            dynamic_range_db=avg_dynamic,
        ),
        spectral=SpectralMetrics(
            spectral_centroid_hz=avg_centroid,
            bass_energy_ratio=avg_bass,
            mid_energy_ratio=avg_mid,
            treble_energy_ratio=avg_treble,
        ),
        advanced=AdvancedMetrics(
            lufs_integrated=avg_lufs,
            transient_density=avg_transient,
            attack_time_ms=avg_attack,
            sustain_decay_rate_db_s=avg_decay,
        ),
    )


def compute_metrics_std(
    all_metrics: Sequence[AudioMetrics],
    mean_metrics: AudioMetrics,
) -> AudioMetrics:
    """Compute standard deviation of metrics across segments.

    Args:
        all_metrics: List of AudioMetrics from all segments
        mean_metrics: Pre-computed mean metrics

    Returns:
        AudioMetrics with standard deviation values
    """
    import math

    if len(all_metrics) < 2:
        # Return zeros for single sample
        from guitar_tone_shootout.metrics import (
            AdvancedMetrics,
            CoreMetrics,
            SpectralMetrics,
        )

        return AudioMetrics(
            duration_seconds=0.0,
            sample_rate=all_metrics[0].sample_rate if all_metrics else 44100,
            core=CoreMetrics(
                rms_dbfs=0.0, peak_dbfs=0.0, crest_factor_db=0.0, dynamic_range_db=0.0
            ),
            spectral=SpectralMetrics(
                spectral_centroid_hz=0.0,
                bass_energy_ratio=0.0,
                mid_energy_ratio=0.0,
                treble_energy_ratio=0.0,
            ),
            advanced=AdvancedMetrics(
                lufs_integrated=0.0,
                transient_density=0.0,
                attack_time_ms=0.0,
                sustain_decay_rate_db_s=0.0,
            ),
        )

    count = len(all_metrics)

    def std(values: list[float], mean: float) -> float:
        variance = sum((v - mean) ** 2 for v in values) / count
        return math.sqrt(variance)

    std_rms = std([m.core.rms_dbfs for m in all_metrics], mean_metrics.core.rms_dbfs)
    std_peak = std([m.core.peak_dbfs for m in all_metrics], mean_metrics.core.peak_dbfs)
    std_crest = std(
        [m.core.crest_factor_db for m in all_metrics], mean_metrics.core.crest_factor_db
    )
    std_dynamic = std(
        [m.core.dynamic_range_db for m in all_metrics], mean_metrics.core.dynamic_range_db
    )

    std_centroid = std(
        [m.spectral.spectral_centroid_hz for m in all_metrics],
        mean_metrics.spectral.spectral_centroid_hz,
    )
    std_bass = std(
        [m.spectral.bass_energy_ratio for m in all_metrics],
        mean_metrics.spectral.bass_energy_ratio,
    )
    std_mid = std(
        [m.spectral.mid_energy_ratio for m in all_metrics],
        mean_metrics.spectral.mid_energy_ratio,
    )
    std_treble = std(
        [m.spectral.treble_energy_ratio for m in all_metrics],
        mean_metrics.spectral.treble_energy_ratio,
    )

    std_lufs = std(
        [m.advanced.lufs_integrated for m in all_metrics],
        mean_metrics.advanced.lufs_integrated,
    )
    std_transient = std(
        [m.advanced.transient_density for m in all_metrics],
        mean_metrics.advanced.transient_density,
    )
    std_attack = std(
        [m.advanced.attack_time_ms for m in all_metrics],
        mean_metrics.advanced.attack_time_ms,
    )
    std_decay = std(
        [m.advanced.sustain_decay_rate_db_s for m in all_metrics],
        mean_metrics.advanced.sustain_decay_rate_db_s,
    )

    from guitar_tone_shootout.metrics import (
        AdvancedMetrics,
        CoreMetrics,
        SpectralMetrics,
    )

    return AudioMetrics(
        duration_seconds=0.0,  # Not meaningful for std
        sample_rate=all_metrics[0].sample_rate,
        core=CoreMetrics(
            rms_dbfs=std_rms,
            peak_dbfs=std_peak,
            crest_factor_db=std_crest,
            dynamic_range_db=std_dynamic,
        ),
        spectral=SpectralMetrics(
            spectral_centroid_hz=std_centroid,
            bass_energy_ratio=std_bass,
            mid_energy_ratio=std_mid,
            treble_energy_ratio=std_treble,
        ),
        advanced=AdvancedMetrics(
            lufs_integrated=std_lufs,
            transient_density=std_transient,
            attack_time_ms=std_attack,
            sustain_decay_rate_db_s=std_decay,
        ),
    )


# =============================================================================
# Algorithmic Summary Generation
# =============================================================================


def _describe_brightness(delta: MetricsDelta) -> str | None:
    """Generate brightness description based on spectral centroid difference."""
    if delta.spectral_centroid_hz > BRIGHTNESS_THRESHOLD_HZ:
        if delta.spectral_centroid_hz > BRIGHTNESS_THRESHOLD_HZ * 3:
            return "significantly brighter tone"
        return "brighter tone"
    elif delta.spectral_centroid_hz < -BRIGHTNESS_THRESHOLD_HZ:
        if delta.spectral_centroid_hz < -BRIGHTNESS_THRESHOLD_HZ * 3:
            return "significantly darker tone"
        return "darker tone"
    return None


def _describe_eq_character(delta: MetricsDelta) -> list[str]:
    """Generate EQ character descriptions based on band energy differences."""
    descriptions: list[str] = []
    descriptions.extend(_describe_bass(delta))
    descriptions.extend(_describe_mids(delta))
    descriptions.extend(_describe_treble(delta))
    return descriptions


def _describe_bass(delta: MetricsDelta) -> list[str]:
    """Generate bass frequency descriptions."""
    if delta.bass_energy_ratio > BASS_ENERGY_THRESHOLD:
        if delta.bass_energy_ratio > BASS_ENERGY_THRESHOLD * 2:
            return ["enhanced low-end presence"]
        return ["slightly fuller bass response"]
    if delta.bass_energy_ratio < -BASS_ENERGY_THRESHOLD:
        if delta.bass_energy_ratio < -BASS_ENERGY_THRESHOLD * 2:
            return ["tighter, leaner low-end"]
        return ["slightly reduced bass"]
    return []


def _describe_mids(delta: MetricsDelta) -> list[str]:
    """Generate midrange frequency descriptions."""
    if delta.mid_energy_ratio > MID_ENERGY_THRESHOLD:
        if delta.mid_energy_ratio > MID_ENERGY_THRESHOLD * 2:
            return ["prominent midrange presence"]
        return ["slightly emphasized mids"]
    if delta.mid_energy_ratio < -MID_ENERGY_THRESHOLD:
        if delta.mid_energy_ratio < -MID_ENERGY_THRESHOLD * 2:
            return ["scooped midrange character"]
        return ["slightly recessed mids"]
    return []


def _describe_treble(delta: MetricsDelta) -> list[str]:
    """Generate treble frequency descriptions."""
    if delta.treble_energy_ratio > TREBLE_ENERGY_THRESHOLD:
        if delta.treble_energy_ratio > TREBLE_ENERGY_THRESHOLD * 2:
            return ["extended high-frequency sparkle"]
        return ["slightly enhanced treble"]
    if delta.treble_energy_ratio < -TREBLE_ENERGY_THRESHOLD:
        if delta.treble_energy_ratio < -TREBLE_ENERGY_THRESHOLD * 2:
            return ["rolled-off highs"]
        return ["slightly softened treble"]
    return []


def _describe_dynamics(delta: MetricsDelta) -> list[str]:
    """Generate dynamics descriptions based on crest factor and dynamic range."""
    descriptions = []

    # Crest factor (transient punch)
    if delta.crest_factor_db > CREST_FACTOR_THRESHOLD_DB:
        if delta.crest_factor_db > CREST_FACTOR_THRESHOLD_DB * 2:
            descriptions.append("highly dynamic with pronounced transient punch")
        else:
            descriptions.append("good transient response")
    elif delta.crest_factor_db < -CREST_FACTOR_THRESHOLD_DB:
        if delta.crest_factor_db < -CREST_FACTOR_THRESHOLD_DB * 2:
            descriptions.append("heavily compressed character")
        else:
            descriptions.append("slightly compressed dynamics")

    # Dynamic range
    if delta.dynamic_range_db > DYNAMIC_RANGE_THRESHOLD_DB:
        descriptions.append("wide dynamic range")
    elif delta.dynamic_range_db < -DYNAMIC_RANGE_THRESHOLD_DB:
        descriptions.append("more consistent/compressed output")

    return descriptions


def _describe_envelope(delta: MetricsDelta) -> list[str]:
    """Generate envelope descriptions based on attack time and sustain decay."""
    descriptions = []

    # Attack time
    if delta.attack_time_ms > ATTACK_TIME_THRESHOLD_MS:
        if delta.attack_time_ms > ATTACK_TIME_THRESHOLD_MS * 3:
            descriptions.append("notably slower attack")
        else:
            descriptions.append("slightly softer pick attack")
    elif delta.attack_time_ms < -ATTACK_TIME_THRESHOLD_MS:
        if delta.attack_time_ms < -ATTACK_TIME_THRESHOLD_MS * 3:
            descriptions.append("very fast, snappy attack")
        else:
            descriptions.append("quick pick response")

    # Sustain decay rate (more negative = faster decay = less sustain)
    if delta.sustain_decay_rate_db_s > DECAY_RATE_THRESHOLD_DB_S:
        # Less negative = slower decay = more sustain
        descriptions.append("reduced sustain")
    elif delta.sustain_decay_rate_db_s < -DECAY_RATE_THRESHOLD_DB_S:
        # More negative = faster decay, but delta negative means segment decays slower
        descriptions.append("enhanced sustain characteristics")

    return descriptions


def _describe_transients(delta: MetricsDelta) -> str | None:
    """Generate transient density description."""
    if delta.transient_density > TRANSIENT_DENSITY_THRESHOLD:
        return "more articulate note definition"
    elif delta.transient_density < -TRANSIENT_DENSITY_THRESHOLD:
        return "smoother, more blended note transitions"
    return None


def _determine_strengths(
    delta: MetricsDelta,
) -> list[str]:
    """Determine tone strengths based on metrics analysis."""
    strengths = []

    # Bright tones are good for cutting through
    if delta.spectral_centroid_hz > BRIGHTNESS_THRESHOLD_HZ:
        strengths.append("Cuts through a mix well")

    # Good transient response
    if delta.crest_factor_db > CREST_FACTOR_THRESHOLD_DB:
        strengths.append("Excellent pick dynamics and articulation")

    # Enhanced sustain
    if delta.sustain_decay_rate_db_s < -DECAY_RATE_THRESHOLD_DB_S:
        strengths.append("Long, singing sustain")

    # Full bass response
    if delta.bass_energy_ratio > BASS_ENERGY_THRESHOLD:
        strengths.append("Full, warm low-end")

    # Prominent mids
    if delta.mid_energy_ratio > MID_ENERGY_THRESHOLD:
        strengths.append("Strong midrange presence for leads")

    # Fast attack
    if delta.attack_time_ms < -ATTACK_TIME_THRESHOLD_MS:
        strengths.append("Immediate pick response")

    # Wide dynamic range
    if delta.dynamic_range_db > DYNAMIC_RANGE_THRESHOLD_DB:
        strengths.append("Responds well to playing dynamics")

    return strengths


def _determine_weaknesses(
    delta: MetricsDelta,
) -> list[str]:
    """Determine tone weaknesses based on metrics analysis."""
    weaknesses = []

    # Very dark tones may get lost in mix
    if delta.spectral_centroid_hz < -BRIGHTNESS_THRESHOLD_HZ * 2:
        weaknesses.append("May get lost in a dense mix")

    # Over-compressed
    if delta.crest_factor_db < -CREST_FACTOR_THRESHOLD_DB * 2:
        weaknesses.append("Limited dynamic expression")

    # Slow attack
    if delta.attack_time_ms > ATTACK_TIME_THRESHOLD_MS * 3:
        weaknesses.append("Slower pick attack may affect precision playing")

    # Scooped mids
    if delta.mid_energy_ratio < -MID_ENERGY_THRESHOLD * 2:
        weaknesses.append("Scooped mids may lack presence in band context")

    # Harsh treble
    if delta.treble_energy_ratio > TREBLE_ENERGY_THRESHOLD * 3:
        weaknesses.append("High frequencies may be fatiguing at volume")

    return weaknesses


def _recommend_genres(
    delta: MetricsDelta,
) -> list[str]:
    """Recommend musical genres based on tonal characteristics."""
    genres = []

    # Bright, articulate tones
    if (
        delta.spectral_centroid_hz > BRIGHTNESS_THRESHOLD_HZ
        and delta.crest_factor_db > 0
    ):
        genres.extend(["country", "pop", "funk"])

    # Dark, compressed tones
    if (
        delta.spectral_centroid_hz < -BRIGHTNESS_THRESHOLD_HZ
        and delta.crest_factor_db < 0
    ):
        genres.extend(["metal", "doom", "stoner rock"])

    # Prominent mids with sustain
    if (
        delta.mid_energy_ratio > MID_ENERGY_THRESHOLD
        and delta.sustain_decay_rate_db_s < 0
    ):
        genres.extend(["blues", "classic rock"])

    # Full bass, dynamic range
    if delta.bass_energy_ratio > BASS_ENERGY_THRESHOLD:
        genres.append("jazz")

    # Scooped with compression
    if (
        delta.mid_energy_ratio < -MID_ENERGY_THRESHOLD
        and delta.crest_factor_db < -CREST_FACTOR_THRESHOLD_DB
    ):
        genres.append("modern metal")

    # Fast attack, articulate
    if delta.attack_time_ms < -ATTACK_TIME_THRESHOLD_MS:
        genres.append("progressive rock")

    # Wide dynamic range
    if delta.dynamic_range_db > DYNAMIC_RANGE_THRESHOLD_DB:
        genres.append("singer-songwriter")

    # Default if no specific recommendations
    if not genres:
        genres = ["rock", "general purpose"]

    return list(dict.fromkeys(genres))  # Remove duplicates while preserving order


def generate_algorithmic_summary(
    segment_metrics: AudioMetrics,
    shootout_averages: AudioMetrics,
    amp_name: str | None = None,
) -> str:
    """Generate a template-based description from metrics comparison.

    This is the REQUIRED evaluation method that produces human-readable
    descriptions based purely on audio engineering metrics analysis.

    Args:
        segment_metrics: Metrics for the segment being evaluated
        shootout_averages: Average metrics across all segments in the shootout
        amp_name: Optional name of the amp/tone being evaluated

    Returns:
        Human-readable description of the tone's characteristics
    """
    delta = compute_metrics_delta(segment_metrics, shootout_averages)

    # Build description parts
    parts: list[str] = []

    # Opening
    if amp_name:
        parts.append(f"The {amp_name} tone")
    else:
        parts.append("This tone")

    # Brightness
    brightness = _describe_brightness(delta)
    if brightness:
        parts[0] += f" exhibits a {brightness}"
    else:
        parts[0] += " has a balanced brightness"

    # EQ character
    eq_parts = _describe_eq_character(delta)
    if eq_parts:
        if len(eq_parts) == 1:
            parts.append(f"with {eq_parts[0]}")
        elif len(eq_parts) == 2:
            parts.append(f"with {eq_parts[0]} and {eq_parts[1]}")
        else:
            parts.append(f"featuring {', '.join(eq_parts[:-1])}, and {eq_parts[-1]}")

    # Dynamics
    dynamics = _describe_dynamics(delta)
    if dynamics:
        parts.append(f"The amp shows {', '.join(dynamics)}.")

    # Envelope
    envelope = _describe_envelope(delta)
    if envelope:
        parts.append(f"It delivers {', '.join(envelope)}.")

    # Transients
    transient_desc = _describe_transients(delta)
    if transient_desc:
        parts.append(f"Note articulation shows {transient_desc}.")

    # Combine with proper punctuation
    result = ". ".join(parts) if len(parts) > 1 else parts[0]
    if not result.endswith("."):
        result += "."

    return result


def generate_algorithmic_evaluation(
    segment_metrics: AudioMetrics,
    shootout_averages: AudioMetrics,
    amp_name: str | None = None,
) -> AIEvaluation:
    """Generate a complete AI evaluation using only algorithmic analysis.

    Args:
        segment_metrics: Metrics for the segment being evaluated
        shootout_averages: Average metrics across all segments
        amp_name: Optional name of the amp/tone

    Returns:
        Complete AIEvaluation with all fields populated
    """
    delta = compute_metrics_delta(segment_metrics, shootout_averages)

    tone_description = generate_algorithmic_summary(
        segment_metrics, shootout_averages, amp_name
    )

    strengths = _determine_strengths(delta)
    weaknesses = _determine_weaknesses(delta)
    genres = _recommend_genres(delta)

    # Generate comparison notes
    comparison_parts = []
    if delta.spectral_centroid_hz > BRIGHTNESS_THRESHOLD_HZ:
        comparison_parts.append(
            f"brighter by {delta.spectral_centroid_hz:.0f} Hz"
        )
    elif delta.spectral_centroid_hz < -BRIGHTNESS_THRESHOLD_HZ:
        comparison_parts.append(
            f"darker by {abs(delta.spectral_centroid_hz):.0f} Hz"
        )

    if abs(delta.lufs_integrated) > 1.0:
        if delta.lufs_integrated > 0:
            comparison_parts.append(f"louder by {delta.lufs_integrated:.1f} LUFS")
        else:
            comparison_parts.append(f"quieter by {abs(delta.lufs_integrated):.1f} LUFS")

    comparison_notes = (
        f"Compared to shootout average: {', '.join(comparison_parts)}"
        if comparison_parts
        else "Similar to shootout average across measured characteristics"
    )

    return AIEvaluation(
        model_name="algorithmic",
        model_version="1.0.0",
        tone_description=tone_description,
        strengths=strengths,
        weaknesses=weaknesses,
        recommended_genres=genres,
        comparison_notes=comparison_notes,
        overall_rating=None,  # Algorithmic doesn't provide rating
        raw_response=None,
    )


# =============================================================================
# LLM Enhancement (Optional)
# =============================================================================


def _get_metrics_cache_key(
    segment_metrics: AudioMetrics,
    shootout_averages: AudioMetrics,
    amp_name: str | None,
) -> str:
    """Generate a cache key for metrics combination."""
    data = {
        "segment": segment_metrics.model_dump_json(),
        "averages": shootout_averages.model_dump_json(),
        "amp_name": amp_name or "",
    }
    content = json.dumps(data, sort_keys=True)
    return hashlib.sha256(content.encode()).hexdigest()


def is_llm_evaluation_enabled() -> bool:
    """Check if LLM evaluation is enabled via environment variable."""
    return os.getenv(ENABLE_LLM_EVALUATION_ENV, "").lower() in ("true", "1", "yes")


def _build_llm_prompt(
    segment_metrics: AudioMetrics,
    shootout_averages: AudioMetrics,
    algorithmic_summary: str,
    amp_name: str | None,
) -> str:
    """Build the prompt for LLM evaluation."""
    delta = compute_metrics_delta(segment_metrics, shootout_averages)
    spectral = segment_metrics.spectral
    bass_mid_treble = f"{spectral.bass_energy_ratio:.2f}/{spectral.mid_energy_ratio:.2f}"
    bass_mid_treble += f"/{spectral.treble_energy_ratio:.2f}"

    lines = [
        "You are an expert guitar tone analyst.",
        "Analyze the following guitar amp tone based on audio metrics.",
        "Provide a natural, engaging description for guitarists.",
        "",
        "## Amp/Tone Name",
        f"{amp_name or 'Unknown Amp'}",
        "",
        "## Algorithmic Analysis",
        algorithmic_summary,
        "",
        "## Metrics Summary (compared to shootout average)",
        f"- Spectral Centroid: {delta.spectral_centroid_hz:+.0f} Hz (brightness)",
        f"- Bass Energy: {delta.bass_energy_ratio:+.3f} ratio",
        f"- Mid Energy: {delta.mid_energy_ratio:+.3f} ratio",
        f"- Treble Energy: {delta.treble_energy_ratio:+.3f} ratio",
        f"- Crest Factor: {delta.crest_factor_db:+.1f} dB (transient punch)",
        f"- Dynamic Range: {delta.dynamic_range_db:+.1f} dB",
        f"- Attack Time: {delta.attack_time_ms:+.1f} ms",
        f"- Sustain Decay: {delta.sustain_decay_rate_db_s:+.1f} dB/s",
        f"- LUFS Difference: {delta.lufs_integrated:+.1f}",
        "",
        "## Absolute Metrics",
        f"- RMS Level: {segment_metrics.core.rms_dbfs:.1f} dBFS",
        f"- Peak Level: {segment_metrics.core.peak_dbfs:.1f} dBFS",
        f"- Spectral Centroid: {spectral.spectral_centroid_hz:.0f} Hz",
        f"- Bass/Mid/Treble: {bass_mid_treble}",
        f"- LUFS: {segment_metrics.advanced.lufs_integrated:.1f}",
        "",
        "Please provide:",
        "1. A vivid, guitar-player-friendly description of this tone (2-3 sentences)",
        "2. Top 3 strengths",
        "3. Any potential weaknesses (if applicable)",
        "4. 3-5 recommended genres",
        "5. An overall quality rating from 1-10",
        "",
        "Format your response as JSON with these keys:",
        "tone_description, strengths (array), weaknesses (array),",
        "recommended_genres (array), overall_rating (number)",
    ]
    return "\n".join(lines)


async def generate_llm_description(
    segment_metrics: AudioMetrics,
    shootout_averages: AudioMetrics,
    algorithmic_summary: str,
    amp_name: str | None = None,
    *,
    cache: dict[str, AIEvaluation] | None = None,
) -> AIEvaluation | None:
    """Generate enhanced natural language description using Claude API.

    This is OPTIONAL and only runs if ENABLE_LLM_EVALUATION=true and
    ANTHROPIC_API_KEY is set.

    Args:
        segment_metrics: Metrics for the segment being evaluated
        shootout_averages: Average metrics across the shootout
        algorithmic_summary: Pre-computed algorithmic summary
        amp_name: Name of the amp/tone being evaluated
        cache: Optional cache dict for storing/retrieving responses

    Returns:
        AIEvaluation with LLM-enhanced description, or None if LLM unavailable
    """
    # Check prerequisites
    result = _check_llm_prerequisites()
    if result is None:
        return None
    api_key = result

    # Check cache
    cache_key = _get_metrics_cache_key(segment_metrics, shootout_averages, amp_name)
    if cache is not None and cache_key in cache:
        logger.debug("Returning cached LLM evaluation")
        return cache[cache_key]

    # Make API call
    prompt = _build_llm_prompt(
        segment_metrics, shootout_averages, algorithmic_summary, amp_name
    )
    data = await _call_claude_api(api_key, prompt)
    if data is None:
        return None

    # Parse response
    evaluation = _parse_claude_response(data, algorithmic_summary)
    if evaluation is None:
        return None

    # Store in cache if provided
    if cache is not None:
        cache[cache_key] = evaluation

    return evaluation


def _check_llm_prerequisites() -> str | None:
    """Check if LLM evaluation can proceed. Returns API key or None."""
    if not is_llm_evaluation_enabled():
        logger.debug("LLM evaluation disabled")
        return None

    api_key = os.getenv(ANTHROPIC_API_KEY_ENV)
    if not api_key:
        logger.warning("ANTHROPIC_API_KEY not set, skipping LLM evaluation")
        return None

    return api_key


async def _call_claude_api(api_key: str, prompt: str) -> dict[str, object] | None:
    """Call Claude API and return response data or None on error."""
    try:
        import httpx
    except ImportError:
        logger.warning("httpx not installed, skipping LLM evaluation")
        return None

    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(
                "https://api.anthropic.com/v1/messages",
                headers={
                    "x-api-key": api_key,
                    "anthropic-version": "2023-06-01",
                    "content-type": "application/json",
                },
                json={
                    "model": "claude-3-5-sonnet-20241022",
                    "max_tokens": 1024,
                    "messages": [{"role": "user", "content": prompt}],
                },
                timeout=30.0,
            )
            response.raise_for_status()
            return response.json()  # type: ignore[no-any-return]
    except Exception as e:
        logger.error(f"Claude API error: {e}")
        return None


def _parse_claude_response(
    data: dict[str, object], fallback_description: str
) -> AIEvaluation | None:
    """Parse Claude API response into AIEvaluation or None on error."""
    try:
        text_content = _extract_text_from_response(data)
        if text_content is None:
            return None

        parsed = _extract_json_from_text(text_content)
        if parsed is None:
            return None

        # Extract values with proper type handling
        tone_desc = parsed.get("tone_description")
        strengths_raw = parsed.get("strengths", [])
        weaknesses_raw = parsed.get("weaknesses", [])
        genres_raw = parsed.get("recommended_genres", [])
        rating_raw = parsed.get("overall_rating")

        return AIEvaluation(
            model_name="claude-3-5-sonnet",
            model_version="20241022",
            tone_description=str(tone_desc) if tone_desc else fallback_description,
            strengths=list(strengths_raw) if isinstance(strengths_raw, list) else [],
            weaknesses=list(weaknesses_raw) if isinstance(weaknesses_raw, list) else [],
            recommended_genres=list(genres_raw) if isinstance(genres_raw, list) else [],
            comparison_notes=None,
            overall_rating=float(str(rating_raw)) if rating_raw is not None else None,
            raw_response=data,
        )
    except Exception as e:
        logger.error(f"Error processing Claude response: {e}")
        return None


def _extract_text_from_response(data: dict[str, object]) -> str | None:
    """Extract text content from Claude API response."""
    content_list = data.get("content", [])
    if not content_list or not isinstance(content_list, list):
        logger.warning("Invalid Claude response structure")
        return None

    first_content = content_list[0]
    if not isinstance(first_content, dict):
        return None

    content = first_content.get("text", "")
    if not isinstance(content, str):
        return None

    return content


def _extract_json_from_text(text: str) -> dict[str, object] | None:
    """Extract JSON object from text content."""
    import re

    json_match = re.search(r"\{[\s\S]*\}", text)
    if not json_match:
        logger.warning("Could not extract JSON from Claude response")
        return None

    try:
        return json.loads(json_match.group())  # type: ignore[no-any-return]
    except json.JSONDecodeError as e:
        logger.warning(f"Failed to parse Claude JSON response: {e}")
        return None


# =============================================================================
# Main Evaluation Function
# =============================================================================


async def generate_evaluation(
    segment_metrics: AudioMetrics,
    shootout_averages: AudioMetrics,
    amp_name: str | None = None,
    *,
    enable_llm: bool | None = None,
    llm_cache: dict[str, AIEvaluation] | None = None,
) -> AIEvaluation:
    """Generate AI evaluation for a tone segment.

    This is the main entry point for evaluation generation. It always
    generates an algorithmic evaluation and optionally enhances it with
    LLM-generated descriptions if enabled.

    Args:
        segment_metrics: Metrics for the segment being evaluated
        shootout_averages: Average metrics across all segments
        amp_name: Optional name of the amp/tone being evaluated
        enable_llm: Override for LLM evaluation (uses env var if None)
        llm_cache: Optional cache for LLM responses

    Returns:
        AIEvaluation with tone description and analysis

    Example:
        >>> metrics = extract_metrics(audio, sample_rate)
        >>> avg = compute_shootout_averages([metrics, other_metrics])
        >>> evaluation = await generate_evaluation(
        ...     metrics, avg, amp_name="JCM800"
        ... )
        >>> print(evaluation.tone_description)
    """
    # Always generate algorithmic evaluation first
    algorithmic_eval = generate_algorithmic_evaluation(
        segment_metrics, shootout_averages, amp_name
    )

    # Check if LLM should be used
    should_use_llm = enable_llm if enable_llm is not None else is_llm_evaluation_enabled()

    if not should_use_llm:
        return algorithmic_eval

    # Try LLM enhancement
    llm_eval = await generate_llm_description(
        segment_metrics,
        shootout_averages,
        algorithmic_eval.tone_description,
        amp_name,
        cache=llm_cache,
    )

    if llm_eval is not None:
        return llm_eval

    # Fall back to algorithmic if LLM fails
    logger.info("LLM evaluation failed, using algorithmic evaluation")
    return algorithmic_eval


def generate_evaluation_sync(
    segment_metrics: AudioMetrics,
    shootout_averages: AudioMetrics,
    amp_name: str | None = None,
) -> AIEvaluation:
    """Synchronous version of generate_evaluation (algorithmic only).

    This is a convenience function for synchronous code that doesn't
    need LLM enhancement.

    Args:
        segment_metrics: Metrics for the segment being evaluated
        shootout_averages: Average metrics across all segments
        amp_name: Optional name of the amp/tone

    Returns:
        AIEvaluation with algorithmic analysis
    """
    return generate_algorithmic_evaluation(
        segment_metrics, shootout_averages, amp_name
    )
